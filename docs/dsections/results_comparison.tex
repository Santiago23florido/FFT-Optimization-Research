\section{Benchmark Results and Comparison}

This section compares the implemented transform models using an automated benchmark and plotting workflow. The evaluated algorithms are \texttt{radix2\_iterative}, \texttt{radix2\_recursive}, \texttt{split\_radix}, and \texttt{direct\_dft}. The measured sizes are \(N\in\{64,128,256,512,1024\}\), with 3 warmup iterations and 20 measured iterations per pair \((\text{algorithm},N)\), using seed 1337.

The plotted quantities are extracted from the benchmark summary data:
\begin{itemize}
\item transform length \(N\);
\item average runtime per transform (microseconds);
\item throughput (processed samples per second).
\item Additional measured descriptors (not shown in the two figures below): median runtime, best-case runtime, worst-case runtime, runtime dispersion (standard deviation), tail latency at the 95th percentile, normalized runtime per sample, and normalized runtime per \(N\log_2 N\).
\end{itemize}

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{figures/mean_runtime.png}
\caption{Mean execution time as a function of signal length \(N\).}
\label{fig:mean_runtime}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{figures/throughput.png}
\caption{Throughput in samples per second as a function of signal length \(N\).}
\label{fig:throughput}
\end{figure}

Figure \ref{fig:mean_runtime} shows the expected complexity separation. The \texttt{direct\_dft} curve grows much faster with \(N\), while the FFT-based models scale substantially better. In this benchmark run at \(N=1024\), mean runtime is approximately 15.27~\(\mu s\) for \texttt{radix2\_iterative}, 25.04~\(\mu s\) for \texttt{split\_radix}, 41.86~\(\mu s\) for \texttt{radix2\_recursive}, and 12,852.67~\(\mu s\) for \texttt{direct\_dft}.

Figure \ref{fig:throughput} presents the same comparison in throughput form. At \(N=1024\), measured throughput is about 67.1 million samples/s for \texttt{radix2\_iterative}, 40.9 million samples/s for \texttt{split\_radix}, 24.5 million samples/s for \texttt{radix2\_recursive}, and 79.7 thousand samples/s for \texttt{direct\_dft}. In this environment, split-radix improves over recursive radix-2, but remains slower than the iterative radix-2 baseline, indicating that lower arithmetic count does not automatically dominate memory traffic and traversal overhead.

These results are consistent with the theoretical complexity analysis and provide a reproducible quantitative baseline for future algorithm extensions and microcontroller-oriented optimization.
